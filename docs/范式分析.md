# SimpleShare 逻辑结构设计 - 范式分析

## 1. 关系模式

### 1.1 Users (用户表)

**关系模式**:
```
Users(id, name, email, password_hash, role, status, storage_quota, storage_used, group_id, created_at, updated_at)
```

**函数依赖**:
- id → name, email, password_hash, role, status, storage_quota, storage_used, group_id, created_at, updated_at
- email → id (唯一约束)

**候选键**: id, email

**主键**: id

**外键**: group_id → UserGroups(id)

### 1.2 Files (文件表)

**关系模式**:
```
Files(id, name, size_bytes, mime_type, storage_key, user_id, parent_id, path, type, starred, download_count, created_at, updated_at)
```

**函数依赖**:
- id → name, size_bytes, mime_type, storage_key, user_id, parent_id, path, type, starred, download_count, created_at, updated_at
- storage_key → id (唯一约束，R2中唯一)

**候选键**: id, storage_key

**主键**: id

**外键**: 
- user_id → Users(id) ON DELETE CASCADE
- parent_id → Files(id) ON DELETE CASCADE

### 1.3 Shares (分享表)

**关系模式**:
```
Shares(id, file_id, user_id, share_code, expiration_days, created_at, expires_at, access_count, max_access)
```

**函数依赖**:
- id → file_id, user_id, share_code, expiration_days, created_at, expires_at, access_count, max_access
- share_code → id (唯一约束)

**候选键**: id, share_code

**主键**: id

**外键**: 
- file_id → Files(id) ON DELETE CASCADE
- user_id → Users(id) ON DELETE CASCADE

### 1.4 UserGroups (用户组表)

**关系模式**:
```
UserGroups(id, name, description, storage_quota, max_users, current_users, permissions, created_at, updated_at)
```

**函数依赖**:
- id → name, description, storage_quota, max_users, current_users, permissions, created_at, updated_at

**候选键**: id

**主键**: id

### 1.5 SystemLogs (系统日志表)

**关系模式**:
```
SystemLogs(id, action, user_id, user_name, status, details, ip, file_id, file_name, created_at)
```

**函数依赖**:
- id → action, user_id, user_name, status, details, ip, file_id, file_name, created_at

**候选键**: id

**主键**: id

**外键**: 
- user_id → Users(id) ON DELETE SET NULL
- file_id → Files(id) ON DELETE SET NULL

## 2. 范式分析

### 2.1 第一范式 (1NF) 分析

**要求**: 每个属性都是原子值，不可再分

**分析结果**: ✅ 所有表都满足1NF

**验证**:
- Users表: 所有属性都是原子值（id, name, email等）
- Files表: 所有属性都是原子值
- Shares表: 所有属性都是原子值
- UserGroups表: permissions字段存储JSON字符串，但作为整体存储，符合1NF
- SystemLogs表: 所有属性都是原子值

### 2.2 第二范式 (2NF) 分析

**要求**: 满足1NF，且非主属性完全依赖于主键（消除部分函数依赖）

**分析结果**: ✅ 所有表都满足2NF

**验证**:

#### Users表
- 主键: id
- 所有非主属性都完全依赖于id
- email虽然唯一，但作为候选键，不构成部分依赖
- ✅ 满足2NF

#### Files表
- 主键: id
- 所有非主属性都完全依赖于id
- storage_key虽然唯一，但作为候选键，不构成部分依赖
- ✅ 满足2NF

#### Shares表
- 主键: id
- 所有非主属性都完全依赖于id
- share_code虽然唯一，但作为候选键，不构成部分依赖
- ✅ 满足2NF

#### UserGroups表
- 主键: id
- 所有非主属性都完全依赖于id
- ✅ 满足2NF

#### SystemLogs表
- 主键: id
- 所有非主属性都完全依赖于id
- ✅ 满足2NF

### 2.3 第三范式 (3NF) 分析

**要求**: 满足2NF，且非主属性不传递依赖于主键（消除传递函数依赖）

**分析结果**: ✅ 所有表都满足3NF

**详细分析**:

#### Users表
- 主键: id
- 函数依赖: id → name, email, password_hash, role, status, storage_quota, storage_used, group_id, created_at, updated_at
- 检查传递依赖:
  - id → group_id → ? (group_id是外键，不传递依赖其他属性)
  - ✅ 无传递依赖
- ✅ 满足3NF

#### Files表
- 主键: id
- 函数依赖: id → name, size_bytes, mime_type, storage_key, user_id, parent_id, path, type, starred, download_count, created_at, updated_at
- 检查传递依赖:
  - id → user_id → ? (user_id是外键，不传递依赖)
  - id → parent_id → ? (parent_id是外键，不传递依赖)
  - ✅ 无传递依赖
- ✅ 满足3NF

#### Shares表
- 主键: id
- 函数依赖: id → file_id, user_id, share_code, expiration_days, created_at, expires_at, access_count, max_access
- 检查传递依赖:
  - id → file_id → ? (file_id是外键，不传递依赖)
  - id → user_id → ? (user_id是外键，不传递依赖)
  - ✅ 无传递依赖
- ✅ 满足3NF

#### UserGroups表
- 主键: id
- 函数依赖: id → name, description, storage_quota, max_users, current_users, permissions, created_at, updated_at
- 检查传递依赖:
  - ✅ 无传递依赖
- ✅ 满足3NF

#### SystemLogs表
- 主键: id
- 函数依赖: id → action, user_id, user_name, status, details, ip, file_id, file_name, created_at
- 检查传递依赖:
  - id → user_id → user_name? (user_name是冗余字段，用于日志查询性能，但user_id是外键，不构成传递依赖)
  - id → file_id → file_name? (file_name是冗余字段，用于日志查询性能，但file_id是外键，不构成传递依赖)
  - 注意: user_name和file_name是为了查询性能而保留的冗余字段，但它们在逻辑上不构成传递依赖（因为user_id和file_id是外键，指向其他表）
  - ✅ 满足3NF（冗余字段是为了性能优化，不是范式违反）

### 2.4 BCNF (Boyce-Codd范式) 分析

**要求**: 满足3NF，且每个决定因素都是候选键

**分析结果**: ✅ 所有表都满足BCNF

**验证**:
- 所有表的主键都是唯一的候选键
- 所有函数依赖的左部都是候选键
- ✅ 满足BCNF

## 3. 范式优化说明

### 3.1 设计优化

虽然所有表都满足3NF和BCNF，但在实际设计中，我们做了一些性能优化：

1. **SystemLogs表的冗余字段**:
   - `user_name`: 虽然可以通过user_id查询Users表获得，但为了日志查询性能，保留此字段
   - `file_name`: 虽然可以通过file_id查询Files表获得，但为了日志查询性能，保留此字段
   - 这些冗余字段在用户或文件被删除后仍然保留，便于审计

2. **Files表的path字段**:
   - 虽然可以通过parent_id递归查询获得完整路径，但为了查询性能，保留path字段
   - path字段在插入和更新时自动维护

### 3.2 索引优化

为了优化查询性能，我们在以下字段上创建了索引：

1. **Users表**:
   - idx_users_email (email) - 用于登录查询

2. **Files表**:
   - idx_files_user_id (user_id) - 用于查询用户文件列表
   - idx_files_parent_id (parent_id) - 用于查询文件夹内容
   - idx_files_path (path) - 用于路径查询

3. **Shares表**:
   - idx_shares_code (share_code) - 用于分享码验证
   - idx_shares_file_id (file_id) - 用于查询文件分享
   - idx_shares_user_id (user_id) - 用于查询用户分享

4. **SystemLogs表**:
   - idx_logs_created_at (created_at) - 用于时间范围查询

## 4. 关系模式总结

| 表名 | 主键 | 外键 | 范式级别 | 说明 |
|------|------|------|---------|------|
| Users | id | group_id | BCNF | 用户基本信息 |
| Files | id | user_id, parent_id | BCNF | 文件元数据 |
| Shares | id | file_id, user_id | BCNF | 分享记录 |
| UserGroups | id | - | BCNF | 用户组信息 |
| SystemLogs | id | user_id, file_id | BCNF | 系统日志 |

## 5. 范式分析结论

✅ **所有关系模式都满足BCNF（Boyce-Codd范式）**

**优点**:
1. 消除了数据冗余
2. 消除了插入、删除、更新异常
3. 保证了数据一致性
4. 优化了查询性能（通过索引）

**设计特点**:
1. 每个表都有明确的主键
2. 外键关系清晰，保证参照完整性
3. 适当的冗余字段用于性能优化（如日志表中的user_name、file_name）
4. 索引设计合理，优化常用查询

## 6. 范式理论应用

本设计严格遵循数据库范式理论：

1. **1NF**: 所有属性都是原子值
2. **2NF**: 消除部分函数依赖
3. **3NF**: 消除传递函数依赖
4. **BCNF**: 所有决定因素都是候选键

同时，在实际应用中，我们平衡了范式要求和性能需求，在保证数据一致性的前提下，适当保留了少量冗余字段以优化查询性能。

